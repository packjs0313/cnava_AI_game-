<!doctype html>
<html lang="ko" class="h-full">
 <head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Shooting Game</title>
  <script src="/_sdk/element_sdk.js"></script>
  <script src="https://cdn.tailwindcss.com"></script>
  <style>
    body {
      box-sizing: border-box;
      margin: 0;
      padding: 0;
      overflow: hidden;
      margin-bottom: -37px;
    }
    
    #gameCanvas {
      display: block;
      background: linear-gradient(135deg, #1a1a2e 0%, #16213e 100%);
    }
    
    .game-ui {
      position: absolute;
      top: 20px;
      left: 20px;
      color: white;
      font-family: Arial, sans-serif;
      z-index: 10;
    }
    
    .health-bar-container {
      width: 200px;
      height: 24px;
      background-color: rgba(255, 255, 255, 0.2);
      border-radius: 12px;
      overflow: hidden;
      border: 2px solid #fff;
    }
    
    .health-bar {
      height: 100%;
      background: linear-gradient(90deg, #ff4444, #ff6b6b);
      transition: width 0.3s ease;
    }
  </style>
  <style>@view-transition { navigation: auto; }</style>
  <script src="/_sdk/data_sdk.js" type="text/javascript"></script>
 </head>
 <body class="h-full">
  <div class="w-full h-full relative">
   <canvas id="gameCanvas"></canvas>
   <div class="game-ui" id="gameUI" style="display: none;">
    <h1 id="gameTitle" style="font-size: 28px; margin: 0 0 10px 0; text-shadow: 2px 2px 4px rgba(0,0,0,0.5);">ÏäàÌåÖ Í≤åÏûÑ</h1>
    <div style="margin-bottom: 8px;"><span id="healthLabel" style="font-size: 16px; font-weight: bold;">Ï≤¥Î†•:</span> <span id="healthValue" style="font-size: 16px; margin-left: 5px;">100</span>
    </div>
    <div class="health-bar-container">
     <div id="healthBar" class="health-bar" style="width: 100%;"></div>
    </div>
    <div style="margin-top: 15px; margin-bottom: 8px;"><span style="font-size: 16px; font-weight: bold;">Î†àÎ≤®: <span id="levelValue">1</span></span>
    </div>
    <div class="health-bar-container" style="background-color: rgba(100, 150, 255, 0.3);">
     <div id="expBar" style="height: 100%; background: linear-gradient(90deg, #4488ff, #66aaff); transition: width: 0.3s ease; width: 0%;"></div>
    </div>
    <div id="playerLabel" style="margin-top: 10px; font-size: 14px; opacity: 0.8;">
     ÌîåÎ†àÏù¥Ïñ¥
    </div>
   </div>
   <div style="position: absolute; top: 20px; right: 20px; color: white; font-family: Arial, sans-serif; z-index: 10; display: flex; align-items: center; gap: 15px;" id="survivalTimeUI">
    <div id="survivalTime" style="font-size: 24px; font-weight: bold; text-shadow: 2px 2px 4px rgba(0,0,0,0.5);">
     ÏÉùÏ°¥ ÏãúÍ∞Ñ: 0:00
    </div><button id="pauseButton" style="background: linear-gradient(135deg, #667eea 0%, #764ba2 100%); color: white; border: none; padding: 10px 20px; border-radius: 8px; font-size: 16px; font-weight: bold; cursor: pointer; box-shadow: 0 4px 6px rgba(0,0,0,0.3); transition: transform 0.2s;">‚è∏Ô∏è Ï†ïÏßÄ</button>
   </div>
  </div>
  <script>
    const defaultConfig = {
      game_title: "ÌÄÄÌÖÄ Ïñ¥ÎìúÎ≤§Ï≤ò",
      player_label: "ÌîåÎ†àÏù¥Ïñ¥",
      health_label: "Ï≤¥Î†•:",
      survival_label: "ÏÉùÏ°¥ ÏãúÍ∞Ñ:",
      background_color: "#1a1a2e",
      player_color: "#00d4ff",
      enemy_color: "#ff4444",
      bullet_color: "#ffff00",
      text_color: "#ffffff"
    };

    const canvas = document.getElementById('gameCanvas');
    const ctx = canvas.getContext('2d');

    function resizeCanvas() {
      canvas.width = window.innerWidth;
      canvas.height = window.innerHeight;
    }
    resizeCanvas();
    window.addEventListener('resize', resizeCanvas);

    const player = {
      x: canvas.width / 2,
      y: canvas.height / 2,
      size: 20,
      speed: 5,
      health: 100,
      maxHealth: 100
    };

    const keys = {};
    const enemies = [];
    const bullets = [];
    const orbs = [];
    const healthOrbs = [];
    let lastEnemySpawn = 0;
    let lastDamageTime = 0;
    const damageInterval = 1000;
    let gameStartTime = Date.now();
    let survivalSeconds = 0;
    let pausedTime = 0;
    let pauseStartTime = 0;
    let lastAutoShoot = 0;
    const autoShootInterval = 1000;
    let enemySpawnInterval = 2000;
    let lastSpawnRateUpdate = Date.now();
    let playerLevel = 1;
    let playerExp = 0;
    let expToNextLevel = 10;
    let levelUpMessageTime = 0;
    let showLevelUpText = false;
    let gamePaused = false;
    let showLevelUpChoice = false;
    let collectRadius = 90;
    let attackSpeedBonus = 0;
    let attackDamage = 10;
    let expMultiplier = 1.0;
    let gameOver = false;
    let gameStarted = false;
    let showStartScreen = true;
    let finalSurvivalTime = '';
    let currentUpgradeOptions = [];
    let showTutorial = false;
    let tutorialPage = 0;

    window.addEventListener('keydown', (e) => {
      keys[e.key.toLowerCase()] = true;
      
      if (showLevelUpChoice) {
        if (e.key === '1') {
          selectUpgrade(0);
        } else if (e.key === '2') {
          selectUpgrade(1);
        } else if (e.key === '3') {
          selectUpgrade(2);
        }
      }
    });

    window.addEventListener('keyup', (e) => {
      keys[e.key.toLowerCase()] = false;
    });

    canvas.addEventListener('mousemove', (e) => {
      const rect = canvas.getBoundingClientRect();
      const scaleX = canvas.width / rect.width;
      const scaleY = canvas.height / rect.height;
      const mouseX = (e.clientX - rect.left) * scaleX;
      const mouseY = (e.clientY - rect.top) * scaleY;
      let isOverButton = false;
      
      if (showTutorial) {
        if (tutorialPage < 2) {
          const nextButtonWidth = 150;
          const nextButtonHeight = 50;
          const nextButtonX = canvas.width / 2 + 20;
          const nextButtonY = canvas.height - 100;
          
          if (mouseX >= nextButtonX && mouseX <= nextButtonX + nextButtonWidth &&
              mouseY >= nextButtonY && mouseY <= nextButtonY + nextButtonHeight) {
            isOverButton = true;
          }
        }
        
        if (tutorialPage > 0) {
          const prevButtonWidth = 150;
          const prevButtonHeight = 50;
          const prevButtonX = canvas.width / 2 - 170;
          const prevButtonY = canvas.height - 100;
          
          if (mouseX >= prevButtonX && mouseX <= prevButtonX + prevButtonWidth &&
              mouseY >= prevButtonY && mouseY <= prevButtonY + prevButtonHeight) {
            isOverButton = true;
          }
        }
        
        if (tutorialPage === 2) {
          const closeButtonWidth = 200;
          const closeButtonHeight = 50;
          const closeButtonX = canvas.width / 2 - closeButtonWidth / 2;
          const closeButtonY = canvas.height - 100;
          
          if (mouseX >= closeButtonX && mouseX <= closeButtonX + closeButtonWidth &&
              mouseY >= closeButtonY && mouseY <= closeButtonY + closeButtonHeight) {
            isOverButton = true;
          }
        }
      } else if (showStartScreen) {
        const buttonWidth = 280;
        const buttonHeight = 75;
        const buttonX = canvas.width / 2 - buttonWidth / 2;
        const buttonY = canvas.height / 2 - 20;
        
        const tutorialTextY = canvas.height / 2 + 85;
        const tutorialButtonWidth = 200;
        const tutorialButtonX = canvas.width / 2 - tutorialButtonWidth / 2;
        const tutorialButtonHeight = 30;
        
        if ((mouseX >= buttonX && mouseX <= buttonX + buttonWidth &&
            mouseY >= buttonY && mouseY <= buttonY + buttonHeight) ||
            (mouseX >= tutorialButtonX && mouseX <= tutorialButtonX + tutorialButtonWidth &&
            mouseY >= tutorialTextY - tutorialButtonHeight/2 && mouseY <= tutorialTextY + tutorialButtonHeight/2)) {
          isOverButton = true;
        }
      } else if (gameOver) {
        const buttonWidth = 200;
        const buttonHeight = 60;
        const buttonX = canvas.width / 2 - buttonWidth / 2;
        const buttonY = canvas.height / 2 + 60;
        
        if (mouseX >= buttonX && mouseX <= buttonX + buttonWidth &&
            mouseY >= buttonY && mouseY <= buttonY + buttonHeight) {
          isOverButton = true;
        }
      } else if (showLevelUpChoice) {
        const boxWidth = 200;
        const boxHeight = 120;
        const boxY = canvas.height / 2 - 30;
        const spacing = 20;
        const totalWidth = boxWidth * 3 + spacing * 2;
        const startX = canvas.width / 2 - totalWidth / 2;
        
        for (let i = 0; i < 3; i++) {
          const boxX = startX + i * (boxWidth + spacing);
          if (mouseX >= boxX && mouseX <= boxX + boxWidth &&
              mouseY >= boxY && mouseY <= boxY + boxHeight) {
            isOverButton = true;
            break;
          }
        }
      }
      
      canvas.style.cursor = isOverButton ? 'pointer' : 'default';
    });

    // Ï†ïÏßÄ Î≤ÑÌäº Ïù¥Î≤§Ìä∏ Î¶¨Ïä§ÎÑà
    document.getElementById('pauseButton').addEventListener('click', () => {
      gamePaused = !gamePaused;
      const pauseButton = document.getElementById('pauseButton');
      if (gamePaused) {
        pauseStartTime = Date.now();
        pauseButton.textContent = '‚ñ∂Ô∏è Í≥ÑÏÜç';
        pauseButton.style.background = 'linear-gradient(135deg, #56ab2f 0%, #a8e063 100%)';
      } else {
        pausedTime += Date.now() - pauseStartTime;
        pauseButton.textContent = '‚è∏Ô∏è Ï†ïÏßÄ';
        pauseButton.style.background = 'linear-gradient(135deg, #667eea 0%, #764ba2 100%)';
      }
    });

    canvas.addEventListener('click', (e) => {
      const rect = canvas.getBoundingClientRect();
      const scaleX = canvas.width / rect.width;
      const scaleY = canvas.height / rect.height;
      const mouseX = (e.clientX - rect.left) * scaleX;
      const mouseY = (e.clientY - rect.top) * scaleY;
      
      // ÌäúÌÜ†Î¶¨ÏñºÏù¥ Ïó¥Î†§ÏûàÏùÑ Îïå
      if (showTutorial) {
        // Îã§Ïùå Î≤ÑÌäº (Ïò§Î•∏Ï™Ω)
        if (tutorialPage < 2) {
          const nextButtonWidth = 150;
          const nextButtonHeight = 50;
          const nextButtonX = canvas.width / 2 + 20;
          const nextButtonY = canvas.height - 100;
          
          if (mouseX >= nextButtonX && mouseX <= nextButtonX + nextButtonWidth &&
              mouseY >= nextButtonY && mouseY <= nextButtonY + nextButtonHeight) {
            tutorialPage++;
            return;
          }
        }
        
        // Ïù¥Ï†Ñ Î≤ÑÌäº (ÏôºÏ™Ω)
        if (tutorialPage > 0) {
          const prevButtonWidth = 150;
          const prevButtonHeight = 50;
          const prevButtonX = canvas.width / 2 - 170;
          const prevButtonY = canvas.height - 100;
          
          if (mouseX >= prevButtonX && mouseX <= prevButtonX + prevButtonWidth &&
              mouseY >= prevButtonY && mouseY <= prevButtonY + prevButtonHeight) {
            tutorialPage--;
            return;
          }
        }
        
        // Îã´Í∏∞ Î≤ÑÌäº (ÎßàÏßÄÎßâ ÌéòÏù¥ÏßÄÏóêÏÑúÎßå)
        if (tutorialPage === 2) {
          const closeButtonWidth = 200;
          const closeButtonHeight = 50;
          const closeButtonX = canvas.width / 2 - closeButtonWidth / 2;
          const closeButtonY = canvas.height - 100;
          
          if (mouseX >= closeButtonX && mouseX <= closeButtonX + closeButtonWidth &&
              mouseY >= closeButtonY && mouseY <= closeButtonY + closeButtonHeight) {
            showTutorial = false;
            tutorialPage = 0;
            return;
          }
          return; // ÎßàÏßÄÎßâ ÌéòÏù¥ÏßÄÏóêÏÑúÎäî Ïó¨Í∏∞ÏÑú Î∞òÌôò
        }
      }
      
      // ÏãúÏûë ÌôîÎ©¥Ïùº Îïå
      if (showStartScreen) {
        // Í≤åÏûÑ ÏãúÏûë Î≤ÑÌäº
        const buttonWidth = 280;
        const buttonHeight = 75;
        const buttonX = canvas.width / 2 - buttonWidth / 2;
        const buttonY = canvas.height / 2 - 20;
        
        if (mouseX >= buttonX && mouseX <= buttonX + buttonWidth &&
            mouseY >= buttonY && mouseY <= buttonY + buttonHeight) {
          startGame();
          return;
        }
        
        // Í≤åÏûÑ Î∞©Î≤ï Î≥¥Í∏∞ Î≤ÑÌäº
        const tutorialTextY = canvas.height / 2 + 85;
        const tutorialButtonWidth = 200;
        const tutorialButtonX = canvas.width / 2 - tutorialButtonWidth / 2;
        const tutorialButtonHeight = 30;
        
        if (mouseX >= tutorialButtonX && mouseX <= tutorialButtonX + tutorialButtonWidth &&
            mouseY >= tutorialTextY - tutorialButtonHeight/2 && mouseY <= tutorialTextY + tutorialButtonHeight/2) {
          showTutorial = true;
          tutorialPage = 0;
          return;
        }
        
        return;
      }
      
      if (gameOver) {
        const buttonWidth = 200;
        const buttonHeight = 60;
        const buttonX = canvas.width / 2 - buttonWidth / 2;
        const buttonY = canvas.height / 2 + 60;
        
        if (mouseX >= buttonX && mouseX <= buttonX + buttonWidth &&
            mouseY >= buttonY && mouseY <= buttonY + buttonHeight) {
          resetGame();
        }
        return;
      }
      
      if (showLevelUpChoice) {
        const boxWidth = 200;
        const boxHeight = 120;
        const boxY = canvas.height / 2 - 30;
        const spacing = 20;
        const totalWidth = boxWidth * 3 + spacing * 2;
        const startX = canvas.width / 2 - totalWidth / 2;
        
        for (let i = 0; i < 3; i++) {
          const boxX = startX + i * (boxWidth + spacing);
          if (mouseX >= boxX && mouseX <= boxX + boxWidth &&
              mouseY >= boxY && mouseY <= boxY + boxHeight) {
            selectUpgrade(i);
            return;
          }
        }
        return;
      }
    });

    function startGame() {
      showStartScreen = false;
      gameStarted = true;
      gameStartTime = Date.now();
      document.getElementById('gameUI').style.display = 'block';
      document.getElementById('survivalTimeUI').style.display = 'block';
    }
    
    function hideUIOnStartScreen() {
      if (showStartScreen || showTutorial) {
        document.getElementById('gameUI').style.display = 'none';
        document.getElementById('survivalTimeUI').style.display = 'none';
      }
    }

    function autoShoot() {
      if (enemies.length === 0) return;
      
      let closestEnemy = enemies[0];
      let minDistance = Math.sqrt(
        Math.pow(player.x - closestEnemy.x, 2) + Math.pow(player.y - closestEnemy.y, 2)
      );
      
      enemies.forEach(enemy => {
        const distance = Math.sqrt(
          Math.pow(player.x - enemy.x, 2) + Math.pow(player.y - enemy.y, 2)
        );
        if (distance < minDistance) {
          minDistance = distance;
          closestEnemy = enemy;
        }
      });
      
      const angle = Math.atan2(closestEnemy.y - player.y, closestEnemy.x - player.x);
      bullets.push({
        x: player.x,
        y: player.y,
        vx: Math.cos(angle) * 8,
        vy: Math.sin(angle) * 8,
        size: 5
      });
    }

    function spawnEnemy() {
      const side = Math.floor(Math.random() * 4);
      let x, y;
      
      switch(side) {
        case 0: x = Math.random() * canvas.width; y = -20; break;
        case 1: x = canvas.width + 20; y = Math.random() * canvas.height; break;
        case 2: x = Math.random() * canvas.width; y = canvas.height + 20; break;
        case 3: x = -20; y = Math.random() * canvas.height; break;
      }
      
      // 1Î∂ÑÎßàÎã§ 20%Ïî© Ï≤¥Î†• Ï¶ùÍ∞Ä Í≥ÑÏÇ∞ (Ïã§Ï†ú ÌîåÎ†àÏù¥ ÏãúÍ∞Ñ Í∏∞Ï§Ä - Ï†ïÏßÄ ÏãúÍ∞Ñ Ï†úÏô∏)
      const actualPlayTime = Date.now() - gameStartTime - pausedTime;
      const oneMinuteIntervals = Math.floor(actualPlayTime / 60000);
      const healthMultiplier = 1 + (oneMinuteIntervals * 0.20);
      const baseHealth = 10;
      const enemyHealth = Math.round(baseHealth * healthMultiplier);
      
      enemies.push({
        x: x,
        y: y,
        size: 18,
        speed: 2,
        health: enemyHealth,
        maxHealth: enemyHealth
      });
    }

    function updatePlayer() {
      if (keys['w'] || keys['arrowup']) player.y -= player.speed;
      if (keys['s'] || keys['arrowdown']) player.y += player.speed;
      if (keys['a'] || keys['arrowleft']) player.x -= player.speed;
      if (keys['d'] || keys['arrowright']) player.x += player.speed;

      player.x = Math.max(player.size, Math.min(canvas.width - player.size, player.x));
      player.y = Math.max(player.size, Math.min(canvas.height - player.size, player.y));
    }

    function updateEnemies() {
      const currentTime = Date.now();
      
      for (let i = enemies.length - 1; i >= 0; i--) {
        const enemy = enemies[i];
        const dx = player.x - enemy.x;
        const dy = player.y - enemy.y;
        const distance = Math.sqrt(dx * dx + dy * dy);
        
        enemy.x += (dx / distance) * enemy.speed;
        enemy.y += (dy / distance) * enemy.speed;

        const playerDist = Math.sqrt(
          Math.pow(player.x - enemy.x, 2) + Math.pow(player.y - enemy.y, 2)
        );
        
        if (playerDist < player.size + enemy.size) {
          player.health = Math.max(0, player.health - 10);
          updateHealthDisplay();
          enemies.splice(i, 1);
          
          if (player.health <= 0) {
            const minutes = Math.floor(survivalSeconds / 60);
            const seconds = survivalSeconds % 60;
            finalSurvivalTime = `${minutes}:${seconds.toString().padStart(2, '0')}`;
            gameOver = true;
            gamePaused = true;
          }
        }
      }
    }

    function updateBullets() {
      for (let bulletIndex = bullets.length - 1; bulletIndex >= 0; bulletIndex--) {
        const bullet = bullets[bulletIndex];
        bullet.x += bullet.vx;
        bullet.y += bullet.vy;

        if (bullet.x < 0 || bullet.x > canvas.width || bullet.y < 0 || bullet.y > canvas.height) {
          bullets.splice(bulletIndex, 1);
          continue;
        }

        for (let enemyIndex = enemies.length - 1; enemyIndex >= 0; enemyIndex--) {
          const enemy = enemies[enemyIndex];
          const dist = Math.sqrt(
            Math.pow(bullet.x - enemy.x, 2) + Math.pow(bullet.y - enemy.y, 2)
          );
          
          if (dist < bullet.size + enemy.size) {
            enemy.health -= attackDamage;
            bullets.splice(bulletIndex, 1);
            
            if (enemy.health <= 0) {
              // Í∏∞Î≥∏ Í≤ΩÌóòÏπò Íµ¨Ïä¨
              orbs.push({
                x: enemy.x,
                y: enemy.y,
                size: 6,
                type: 'exp'
              });
              
              // 5% ÌôïÎ•†Î°ú Ï≤¥Î†• ÌöåÎ≥µ Íµ¨Ïä¨
              if (Math.random() < 0.05) {
                healthOrbs.push({
                  x: enemy.x,
                  y: enemy.y,
                  size: 8,
                  type: 'health'
                });
              }
              
              enemies.splice(enemyIndex, 1);
            }
            break;
          }
        }
      }
    }

    function updateOrbs() {
      // Í≤ΩÌóòÏπò Íµ¨Ïä¨ ÏóÖÎç∞Ïù¥Ìä∏
      for (let i = orbs.length - 1; i >= 0; i--) {
        const orb = orbs[i];
        const dist = Math.sqrt(
          Math.pow(player.x - orb.x, 2) + Math.pow(player.y - orb.y, 2)
        );
        
        if (dist <= collectRadius) {
          const dx = player.x - orb.x;
          const dy = player.y - orb.y;
          const moveSpeed = 8;
          
          orb.x += (dx / dist) * moveSpeed;
          orb.y += (dy / dist) * moveSpeed;
          
          if (dist < player.size + orb.size) {
            playerExp += Math.round(1 * expMultiplier);
            orbs.splice(i, 1);
            
            if (playerExp >= expToNextLevel) {
              playerLevel++;
              playerExp = 0;
              expToNextLevel += 10;
              showLevelUpMessage();
            }
            
            updateLevelDisplay();
          }
        }
      }
      
      // Ï≤¥Î†• ÌöåÎ≥µ Íµ¨Ïä¨ ÏóÖÎç∞Ïù¥Ìä∏
      for (let i = healthOrbs.length - 1; i >= 0; i--) {
        const orb = healthOrbs[i];
        const dist = Math.sqrt(
          Math.pow(player.x - orb.x, 2) + Math.pow(player.y - orb.y, 2)
        );
        
        if (dist <= collectRadius) {
          const dx = player.x - orb.x;
          const dy = player.y - orb.y;
          const moveSpeed = 8;
          
          orb.x += (dx / dist) * moveSpeed;
          orb.y += (dy / dist) * moveSpeed;
          
          if (dist < player.size + orb.size) {
            const healAmount = player.maxHealth * 0.1;
            player.health = Math.min(player.maxHealth, player.health + healAmount);
            updateHealthDisplay();
            healthOrbs.splice(i, 1);
          }
        }
      }
    }

    function updateHealthDisplay() {
      const healthValue = document.getElementById('healthValue');
      const healthBar = document.getElementById('healthBar');
      
      healthValue.textContent = Math.round(player.health);
      healthBar.style.width = (player.health / player.maxHealth * 100) + '%';
    }

    function showLevelUpMessage() {
      gamePaused = true;
      showLevelUpChoice = true;
      
      // 5Í∞ÄÏßÄ ÏóÖÍ∑∏Î†àÏù¥Îìú ÏòµÏÖò Ï†ïÏùò
      const allUpgrades = [
        {
          type: 'health',
          name: 'Ï≤¥Î†•',
          color: 'rgba(255, 68, 68, 0.3)',
          borderColor: '#ff4444',
          weight: 21.25
        },
        {
          type: 'attackSpeed',
          name: 'Í≥µÏÜç',
          color: 'rgba(255, 255, 0, 0.3)',
          borderColor: '#ffff00',
          weight: 21.25
        },
        {
          type: 'collectRange',
          name: 'ÌöçÎìùÎ≤îÏúÑ',
          color: 'rgba(0, 212, 255, 0.3)',
          borderColor: '#00d4ff',
          weight: 21.25
        },
        {
          type: 'attackDamage',
          name: 'Í≥µÍ≤©Î†•',
          color: 'rgba(138, 43, 226, 0.3)',
          borderColor: '#8a2be2',
          weight: 21.25
        },
        {
          type: 'expMultiplier',
          name: 'Í≤ΩÌóòÏπòÎüâ',
          color: 'rgba(255, 215, 0, 0.3)',
          borderColor: '#ffd700',
          weight: 15
        }
      ];
      
      function weightedRandomSelect(items, count) {
        const selected = [];
        const available = [...items];
        
        for (let i = 0; i < count && available.length > 0; i++) {
          const totalWeight = available.reduce((sum, item) => sum + item.weight, 0);
          let random = Math.random() * totalWeight;
          
          let selectedIndex = 0;
          for (let j = 0; j < available.length; j++) {
            random -= available[j].weight;
            if (random <= 0) {
              selectedIndex = j;
              break;
            }
          }
          
          selected.push(available[selectedIndex]);
          available.splice(selectedIndex, 1);
        }
        
        return selected;
      }
      
      const selectedUpgrades = weightedRandomSelect(allUpgrades, 3);
      
      currentUpgradeOptions = selectedUpgrades.map(upgrade => ({
        ...upgrade,
        value: upgrade.type === 'expMultiplier' ? 200 : Math.floor(Math.random() * 11) + 20
      }));
    }

    function selectUpgrade(index) {
      const upgrade = currentUpgradeOptions[index];
      const value = upgrade.value / 100;
      
      if (upgrade.type === 'health') {
        const healthIncrease = player.maxHealth * value;
        player.maxHealth += healthIncrease;
        player.health += healthIncrease;
        updateHealthDisplay();
      } else if (upgrade.type === 'attackSpeed') {
        attackSpeedBonus += value;
      } else if (upgrade.type === 'collectRange') {
        collectRadius += collectRadius * value;
      } else if (upgrade.type === 'attackDamage') {
        attackDamage += attackDamage * value;
      } else if (upgrade.type === 'expMultiplier') {
        expMultiplier += value;
      }
      
      showLevelUpChoice = false;
      gamePaused = false;
    }

    function updateLevelDisplay() {
      const levelValue = document.getElementById('levelValue');
      const expBar = document.getElementById('expBar');
      const textColor = window.elementSdk?.config?.text_color || defaultConfig.text_color;
      
      levelValue.textContent = playerLevel;
      levelValue.style.color = textColor;
      expBar.style.width = (playerExp / expToNextLevel * 100) + '%';
    }

    function updateSurvivalTime() {
      const actualPlayTime = Date.now() - gameStartTime - pausedTime;
      survivalSeconds = Math.floor(actualPlayTime / 1000);
      const minutes = Math.floor(survivalSeconds / 60);
      const seconds = survivalSeconds % 60;
      
      const survivalTimeElement = document.getElementById('survivalTime');
      const label = window.elementSdk?.config?.survival_label || defaultConfig.survival_label;
      survivalTimeElement.textContent = `${label} ${minutes}:${seconds.toString().padStart(2, '0')}`;
    }

    function resetGame() {
      player.health = 100;
      player.maxHealth = 100;
      player.x = canvas.width / 2;
      player.y = canvas.height / 2;
      enemies.length = 0;
      bullets.length = 0;
      orbs.length = 0;
      healthOrbs.length = 0;
      lastDamageTime = 0;
      gameStartTime = Date.now();
      survivalSeconds = 0;
      pausedTime = 0;
      pauseStartTime = 0;
      lastAutoShoot = 0;
      enemySpawnInterval = 2000;
      lastSpawnRateUpdate = Date.now();
      playerLevel = 1;
      playerExp = 0;
      expToNextLevel = 10;
      levelUpMessageTime = 0;
      showLevelUpText = false;
      gamePaused = false;
      showLevelUpChoice = false;
      collectRadius = 90;
      attackSpeedBonus = 0;
      attackDamage = 10;
      expMultiplier = 1.0;
      gameOver = false;
      gameStarted = false;
      showStartScreen = true;
      finalSurvivalTime = '';
      currentUpgradeOptions = [];
      document.getElementById('gameUI').style.display = 'none';
      document.getElementById('survivalTimeUI').style.display = 'none';
      updateHealthDisplay();
      updateSurvivalTime();
      updateLevelDisplay();
    }

    function draw() {
      ctx.fillStyle = window.elementSdk?.config?.background_color || defaultConfig.background_color;
      ctx.fillRect(0, 0, canvas.width, canvas.height);

      if (showStartScreen && !showTutorial) {
        const textColor = window.elementSdk?.config?.text_color || defaultConfig.text_color;
        const gameTitle = window.elementSdk?.config?.game_title || defaultConfig.game_title;
        const playerColor = window.elementSdk?.config?.player_color || defaultConfig.player_color;
        
        // Î∞∞Í≤Ω Í∑∏ÎùºÎç∞Ïù¥ÏÖò Ïò§Î≤ÑÎ†àÏù¥
        const gradient = ctx.createRadialGradient(canvas.width / 2, canvas.height / 2, 0, canvas.width / 2, canvas.height / 2, canvas.width / 2);
        gradient.addColorStop(0, 'rgba(0, 212, 255, 0.05)');
        gradient.addColorStop(1, 'rgba(0, 0, 0, 0.3)');
        ctx.fillStyle = gradient;
        ctx.fillRect(0, 0, canvas.width, canvas.height);
        
        // Ïû•ÏãùÏö© ÏõêÎì§ (Î∞∞Í≤Ω)
        for (let i = 0; i < 3; i++) {
          ctx.beginPath();
          ctx.arc(canvas.width / 2, canvas.height / 2 - 100, 150 + i * 40, 0, Math.PI * 2);
          ctx.strokeStyle = `rgba(0, 212, 255, ${0.1 - i * 0.03})`;
          ctx.lineWidth = 2;
          ctx.stroke();
        }
        
        // Í≤åÏûÑ ÌÉÄÏù¥ÌãÄ
        ctx.fillStyle = playerColor;
        ctx.font = 'bold 86px Arial';
        ctx.textAlign = 'center';
        ctx.textBaseline = 'middle';
        ctx.shadowColor = playerColor;
        ctx.shadowBlur = 30;
        ctx.fillText(gameTitle, canvas.width / 2, canvas.height / 2 - 140);
        ctx.shadowBlur = 0;
        
        // ÏÑúÎ∏å ÌÉÄÏù¥ÌãÄ
        ctx.fillStyle = textColor;
        ctx.globalAlpha = 0.8;
        ctx.font = '24px Arial';
        ctx.fillText('ÏÉùÏ°¥Ìòï ÏäàÌåÖ Í≤åÏûÑ', canvas.width / 2, canvas.height / 2 - 80);
        ctx.globalAlpha = 1;
        
        // ÏãúÏûë Î≤ÑÌäº
        const buttonWidth = 280;
        const buttonHeight = 75;
        const buttonX = canvas.width / 2 - buttonWidth / 2;
        const buttonY = canvas.height / 2 - 20;
        
        // Î≤ÑÌäº Í∏ÄÎ°úÏö∞ Ìö®Í≥º
        ctx.shadowColor = playerColor;
        ctx.shadowBlur = 25;
        
        // Î≤ÑÌäº Í∑∏ÎùºÎç∞Ïù¥ÏÖò
        const buttonGradient = ctx.createLinearGradient(buttonX, buttonY, buttonX, buttonY + buttonHeight);
        buttonGradient.addColorStop(0, playerColor);
        buttonGradient.addColorStop(1, adjustBrightness(playerColor, -30));
        
        ctx.fillStyle = buttonGradient;
        roundRect(ctx, buttonX, buttonY, buttonWidth, buttonHeight, 15);
        ctx.fill();
        
        ctx.strokeStyle = adjustBrightness(playerColor, 40);
        ctx.lineWidth = 3;
        ctx.stroke();
        ctx.shadowBlur = 0;
        
        // Î≤ÑÌäº ÌÖçÏä§Ìä∏
        ctx.fillStyle = '#ffffff';
        ctx.font = 'bold 34px Arial';
        ctx.shadowColor = 'rgba(0, 0, 0, 0.5)';
        ctx.shadowBlur = 5;
        ctx.fillText('‚ñ∂ Í≤åÏûÑ ÏãúÏûë', canvas.width / 2, buttonY + buttonHeight / 2);
        ctx.shadowBlur = 0;
        
        // Í≤åÏûÑ Î∞©Î≤ï Î≥¥Í∏∞ ÌÖçÏä§Ìä∏ (ÌÅ¥Î¶≠ Í∞ÄÎä•)
        ctx.fillStyle = textColor;
        ctx.globalAlpha = 0.7;
        ctx.font = '18px Arial';
        const tutorialTextY = canvas.height / 2 + 85;
        ctx.fillText('üìñ Í≤åÏûÑ Î∞©Î≤ï Î≥¥Í∏∞', canvas.width / 2, tutorialTextY);
        
        // Î∞ëÏ§Ñ Ìö®Í≥º (ÏßßÍ≤å)
        const underlineWidth = 140;
        ctx.strokeStyle = textColor;
        ctx.lineWidth = 1;
        ctx.beginPath();
        ctx.moveTo(canvas.width / 2 - underlineWidth / 2, tutorialTextY + 5);
        ctx.lineTo(canvas.width / 2 + underlineWidth / 2, tutorialTextY + 5);
        ctx.stroke();
        ctx.globalAlpha = 1;
        
        return;
      }
      
      // ÌäúÌÜ†Î¶¨Ïñº ÌôîÎ©¥
      if (showTutorial) {
        // Î∞òÌà¨Î™Ö Î∞∞Í≤Ω
        ctx.fillStyle = 'rgba(0, 0, 0, 0.95)';
        ctx.fillRect(0, 0, canvas.width, canvas.height);
        
        const textColor = window.elementSdk?.config?.text_color || defaultConfig.text_color;
        const playerColor = window.elementSdk?.config?.player_color || defaultConfig.player_color;
        const enemyColor = window.elementSdk?.config?.enemy_color || defaultConfig.enemy_color;
        const bulletColor = window.elementSdk?.config?.bullet_color || defaultConfig.bullet_color;
        
        // ÌéòÏù¥ÏßÄ 1: Í≤åÏûÑ ÏÜåÍ∞ú
        if (tutorialPage === 0) {
          ctx.fillStyle = playerColor;
          ctx.font = 'bold 48px Arial';
          ctx.textAlign = 'center';
          ctx.fillText('üéÆ Í≤åÏûÑ ÏÜåÍ∞ú', canvas.width / 2, 100);
          
          ctx.fillStyle = textColor;
          ctx.font = '24px Arial';
          ctx.fillText('ÎÅùÏóÜÏù¥ Î™∞Î†§Ïò§Îäî Ï†ÅÎì§ÏùÑ Î¨ºÎ¶¨ÏπòÍ≥†', canvas.width / 2, 200);
          ctx.fillText('ÏµúÎåÄÌïú Ïò§Îûò ÏÉùÏ°¥ÌïòÎäî Í≤åÏûÑÏûÖÎãàÎã§!', canvas.width / 2, 240);
          
          // Í≤åÏûÑ ÏöîÏÜå ÏãúÏó∞
          const demoY = 320;
          
          // ÌîåÎ†àÏù¥Ïñ¥
          ctx.fillStyle = playerColor;
          ctx.beginPath();
          ctx.arc(canvas.width / 2 - 250, demoY, 20, 0, Math.PI * 2);
          ctx.fill();
          ctx.fillStyle = textColor;
          ctx.font = '18px Arial';
          ctx.fillText('ÌîåÎ†àÏù¥Ïñ¥ (ÎãπÏã†)', canvas.width / 2 - 250, demoY + 50);
          
          // Ï†Å
          ctx.fillStyle = enemyColor;
          ctx.beginPath();
          ctx.arc(canvas.width / 2 - 80, demoY, 18, 0, Math.PI * 2);
          ctx.fill();
          ctx.fillStyle = textColor;
          ctx.fillText('Ï†Å', canvas.width / 2 - 80, demoY + 50);
          
          // Í≤ΩÌóòÏπò Íµ¨Ïä¨
          ctx.fillStyle = '#ffffff';
          ctx.beginPath();
          ctx.arc(canvas.width / 2 + 90, demoY, 6, 0, Math.PI * 2);
          ctx.fill();
          ctx.strokeStyle = '#aaaaaa';
          ctx.lineWidth = 1;
          ctx.stroke();
          ctx.fillStyle = textColor;
          ctx.fillText('Í≤ΩÌóòÏπò Íµ¨Ïä¨', canvas.width / 2 + 90, demoY + 50);
          
          // Ï≤¥Î†• ÌöåÎ≥µ Íµ¨Ïä¨
          ctx.fillStyle = '#00ff00';
          ctx.beginPath();
          ctx.arc(canvas.width / 2 + 250, demoY, 8, 0, Math.PI * 2);
          ctx.fill();
          ctx.strokeStyle = '#00aa00';
          ctx.lineWidth = 2;
          ctx.stroke();
          ctx.fillStyle = textColor;
          ctx.fillText('ÔøΩÔøΩÔøΩÎ†• ÌöåÎ≥µ (5%)', canvas.width / 2 + 250, demoY + 50);
          
          ctx.font = '20px Arial';
          ctx.fillStyle = textColor;
          ctx.globalAlpha = 0.8;
          ctx.fillText('ÏãúÍ∞ÑÏù¥ ÏßÄÎÇ†ÏàòÎ°ù Ï†ÅÏù¥ Îçî ÎßéÏù¥ Îì±Ïû•Ìï©ÎãàÎã§', canvas.width / 2, 450);
          ctx.fillText('Î†àÎ≤®ÏóÖÌïòÏó¨ Í∞ïÌï¥ÏßÄÏÑ∏Ïöî!', canvas.width / 2, 490);
          ctx.globalAlpha = 1;
        }
        
        // ÌéòÏù¥ÏßÄ 2: Ï°∞ÏûëÎ≤ï
        else if (tutorialPage === 1) {
          ctx.fillStyle = playerColor;
          ctx.font = 'bold 48px Arial';
          ctx.textAlign = 'center';
          ctx.fillText('‚å®Ô∏è Ï°∞ÏûëÎ≤ï', canvas.width / 2, 100);
          
          const controlY = 200;
          const spacing = 90;
          
          // WASD Ï°∞Ïûë
          ctx.fillStyle = 'rgba(255, 255, 255, 0.1)';
          ctx.fillRect(canvas.width / 2 - 300, controlY, 600, 70);
          ctx.fillStyle = textColor;
          ctx.font = 'bold 24px Arial';
          ctx.textAlign = 'left';
          ctx.fillText('üéÆ Ïù¥Îèô', canvas.width / 2 - 280, controlY + 45);
          ctx.font = '20px Arial';
          ctx.fillText('W A S D  ÎòêÎäî  ‚Üë ‚Üê ‚Üì ‚Üí', canvas.width / 2 - 50, controlY + 45);
          
          // ÏûêÎèô Í≥µÍ≤©
          ctx.fillStyle = 'rgba(255, 255, 255, 0.1)';
          ctx.fillRect(canvas.width / 2 - 300, controlY + spacing, 600, 70);
          ctx.fillStyle = textColor;
          ctx.font = 'bold 24px Arial';
          ctx.textAlign = 'left';
          ctx.fillText('üî´ Í≥µÍ≤©', canvas.width / 2 - 280, controlY + spacing + 45);
          ctx.font = '20px Arial';
          ctx.fillText('ÏûêÎèôÏúºÎ°ú Í∞ÄÏû• Í∞ÄÍπåÏö¥ Ï†Å Í≥µÍ≤©', canvas.width / 2 - 50, controlY + spacing + 45);
          
          // Î†àÎ≤®ÏóÖ
          ctx.fillStyle = 'rgba(255, 255, 255, 0.1)';
          ctx.fillRect(canvas.width / 2 - 300, controlY + spacing * 2, 600, 70);
          ctx.fillStyle = textColor;
          ctx.font = 'bold 24px Arial';
          ctx.textAlign = 'left';
          ctx.fillText('‚≠ê Î†àÎ≤®ÏóÖ', canvas.width / 2 - 280, controlY + spacing * 2 + 45);
          ctx.font = '20px Arial';
          ctx.fillText('1, 2, 3 ÌÇ§Î°ú ÏóÖÍ∑∏Î†àÏù¥Îìú ÏÑ†ÌÉù', canvas.width / 2 - 50, controlY + spacing * 2 + 45);
          
          // ÏãúÏó∞ Ïï†ÎãàÎ©îÏù¥ÏÖò
          ctx.textAlign = 'center';
          ctx.font = '18px Arial';
          ctx.globalAlpha = 0.7;
          ctx.fillText('üí° Tip: Ï†ÅÏùÑ Ï≤òÏπòÌïòÎ©¥ Í≤ΩÌóòÏπò Íµ¨Ïä¨Ïù¥ ÎÇòÏòµÎãàÎã§', canvas.width / 2, controlY + spacing * 3 + 30);
          ctx.globalAlpha = 1;
        }
        
        // ÌéòÏù¥ÏßÄ 3: ÏóÖÍ∑∏Î†àÏù¥Îìú
        else if (tutorialPage === 2) {
          ctx.fillStyle = playerColor;
          ctx.font = 'bold 48px Arial';
          ctx.textAlign = 'center';
          ctx.fillText('‚≠ê ÏóÖÍ∑∏Î†àÏù¥Îìú', canvas.width / 2, 100);
          
          ctx.fillStyle = textColor;
          ctx.font = '22px Arial';
          ctx.fillText('Î†àÎ≤®ÏóÖ Ïãú 3Í∞ÄÏßÄ Ï§ë ÌïòÔøΩÔøΩÎ•º ÏÑ†ÌÉùÔøΩÔøΩÔøΩ Ïàò ÏûàÏäµÎãàÎã§', canvas.width / 2, 180);
          
          const upgradeY = 250;
          const upgradeSpacing = 80;
          
          const upgrades = [
            { icon: '‚ù§Ô∏è', name: 'Ï≤¥Î†•', desc: 'ÏµúÎåÄ Ï≤¥Î†•Í≥º ÌòÑÏû¨ Ï≤¥Î†• Ï¶ùÍ∞Ä', color: '#ff4444' },
            { icon: '‚ö°', name: 'Í≥µÍ≤© ÏÜçÎèÑ', desc: 'Îçî Îπ†Î•¥Í≤å Ï¥ùÏïå Î∞úÏÇ¨', color: '#ffff00' },
            { icon: 'üó°', name: 'Í≥µÍ≤©Î†•', desc: 'Ï¥ùÏïåÏùò Îç∞ÎØ∏ÏßÄ Ï¶ùÍ∞Ä', color: '#8a2be2' },
            { icon: 'üß≤', name: 'ÌöçÎìù Î≤îÏúÑ', desc: 'Í≤ΩÌóòÏπò Íµ¨Ïä¨ ÏàòÏßë Î≤îÏúÑ Ï¶ùÍ∞Ä', color: '#00d4ff' },
            { icon: '‚≠ê', name: 'Í≤ΩÌóòÏπòÎüâ', desc: 'ÌöçÎìùÌïòÎäî Í≤ΩÌóòÏπò Ï¶ùÍ∞Ä (Ìù¨Í∑Ä)', color: '#ffd700' }
          ];
          
          ctx.font = '18px Arial';
          ctx.textAlign = 'left';
          
          upgrades.forEach((upgrade, i) => {
            const y = upgradeY + i * upgradeSpacing;
            
            ctx.fillStyle = 'rgba(255, 255, 255, 0.05)';
            ctx.fillRect(canvas.width / 2 - 320, y, 640, 60);
            
            ctx.font = '32px Arial';
            ctx.fillText(upgrade.icon, canvas.width / 2 - 300, y + 40);
            
            ctx.fillStyle = upgrade.color;
            ctx.font = 'bold 20px Arial';
            ctx.fillText(upgrade.name, canvas.width / 2 - 250, y + 30);
            
            ctx.fillStyle = textColor;
            ctx.globalAlpha = 0.8;
            ctx.font = '16px Arial';
            ctx.fillText(upgrade.desc, canvas.width / 2 - 250, y + 50);
            ctx.globalAlpha = 1;
          });
        }
        
        // ÌéòÏù¥ÏßÄ Ïù∏ÎîîÏºÄÏù¥ÌÑ∞
        const indicatorY = canvas.height - 150;
        for (let i = 0; i < 3; i++) {
          ctx.fillStyle = i === tutorialPage ? playerColor : 'rgba(255, 255, 255, 0.3)';
          ctx.beginPath();
          ctx.arc(canvas.width / 2 - 30 + i * 30, indicatorY, 6, 0, Math.PI * 2);
          ctx.fill();
        }
        
        // ÎÇ¥ÎπÑÍ≤åÏù¥ÏÖò Î≤ÑÌäº
        ctx.textAlign = 'center';
        
        // ÎßàÏßÄÎßâ ÌéòÏù¥ÏßÄ: Îã´Í∏∞ Î≤ÑÌäºÎßå ÌëúÏãú
        if (tutorialPage === 2) {
          const closeButtonX = canvas.width / 2 - 100;
          const closeButtonY = canvas.height - 100;
          
          ctx.fillStyle = playerColor;
          ctx.fillRect(closeButtonX, closeButtonY, 200, 50);
          ctx.strokeStyle = adjustBrightness(playerColor, 40);
          ctx.lineWidth = 2;
          ctx.strokeRect(closeButtonX, closeButtonY, 200, 50);
          
          ctx.fillStyle = '#ffffff';
          ctx.font = 'bold 18px Arial';
          ctx.textAlign = 'center';
          ctx.fillText('‚úì Ïù¥Ìï¥ÌñàÏäµÎãàÎã§!', closeButtonX + 100, closeButtonY + 32);
        } else {
          // Ïù¥Ï†Ñ/Îã§Ïùå Î≤ÑÌäº (ÎßàÏßÄÎßâ ÌéòÏù¥ÏßÄÍ∞Ä ÏïÑÎãê ÎïåÎßå)
          ctx.textAlign = 'center';
          
          // Ïù¥Ï†Ñ Î≤ÑÌäº
          if (tutorialPage > 0) {
            const prevButtonX = canvas.width / 2 - 170;
            const prevButtonY = canvas.height - 100;
            
            ctx.fillStyle = 'rgba(255, 255, 255, 0.2)';
            ctx.fillRect(prevButtonX, prevButtonY, 150, 50);
            ctx.strokeStyle = textColor;
            ctx.lineWidth = 2;
            ctx.strokeRect(prevButtonX, prevButtonY, 150, 50);
            
            ctx.fillStyle = textColor;
            ctx.font = 'bold 18px Arial';
            ctx.fillText('‚Üê Ïù¥Ï†Ñ', prevButtonX + 75, prevButtonY + 32);
          }
          
          // Îã§Ïùå Î≤ÑÌäº
          if (tutorialPage < 2) {
            const nextButtonX = canvas.width / 2 + 20;
            const nextButtonY = canvas.height - 100;
            
            ctx.fillStyle = playerColor;
            ctx.fillRect(nextButtonX, nextButtonY, 150, 50);
            ctx.strokeStyle = adjustBrightness(playerColor, 40);
            ctx.lineWidth = 2;
            ctx.strokeRect(nextButtonX, nextButtonY, 150, 50);
            
            ctx.fillStyle = '#ffffff';
            ctx.font = 'bold 18px Arial';
            ctx.fillText('Îã§Ïùå ‚Üí', nextButtonX + 75, nextButtonY + 32);
          }
        }
        
        return;
      }
      
    // Îë•Í∑º ÏÇ¨Í∞ÅÌòï Í∑∏Î¶¨Í∏∞ Ìó¨Ìçº Ìï®Ïàò
    function roundRect(ctx, x, y, width, height, radius) {
      ctx.beginPath();
      ctx.moveTo(x + radius, y);
      ctx.lineTo(x + width - radius, y);
      ctx.quadraticCurveTo(x + width, y, x + width, y + radius);
      ctx.lineTo(x + width, y + height - radius);
      ctx.quadraticCurveTo(x + width, y + height, x + width - radius, y + height);
      ctx.lineTo(x + radius, y + height);
      ctx.quadraticCurveTo(x, y + height, x, y + height - radius);
      ctx.lineTo(x, y + radius);
      ctx.quadraticCurveTo(x, y, x + radius, y);
      ctx.closePath();
    }
    
    // ÏÉâÏÉÅ Î∞ùÍ∏∞ Ï°∞Ï†à Ìó¨Ìçº Ìï®Ïàò
    function adjustBrightness(hex, amount) {
      const num = parseInt(hex.replace('#', ''), 16);
      const r = Math.max(0, Math.min(255, (num >> 16) + amount));
      const g = Math.max(0, Math.min(255, ((num >> 8) & 0x00FF) + amount));
      const b = Math.max(0, Math.min(255, (num & 0x0000FF) + amount));
      return '#' + ((r << 16) | (g << 8) | b).toString(16).padStart(6, '0');
    }

      if (!gameStarted) return;

      const playerColor = window.elementSdk?.config?.player_color || defaultConfig.player_color;
      
      ctx.fillStyle = playerColor;
      ctx.beginPath();
      ctx.arc(player.x, player.y, player.size, 0, Math.PI * 2);
      ctx.fill();
      
      ctx.strokeStyle = '#ffffff';
      ctx.lineWidth = 2;
      ctx.stroke();

      const enemyColor = window.elementSdk?.config?.enemy_color || defaultConfig.enemy_color;
      enemies.forEach(enemy => {
        ctx.fillStyle = enemyColor;
        ctx.beginPath();
        ctx.arc(enemy.x, enemy.y, enemy.size, 0, Math.PI * 2);
        ctx.fill();
        
        const barWidth = 30;
        const barHeight = 4;
        const barX = enemy.x - barWidth / 2;
        const barY = enemy.y - enemy.size - 10;
        
        ctx.fillStyle = 'rgba(0, 0, 0, 0.5)';
        ctx.fillRect(barX, barY, barWidth, barHeight);
        
        const healthPercent = enemy.health / enemy.maxHealth;
        ctx.fillStyle = healthPercent > 0.5 ? '#00ff00' : healthPercent > 0.25 ? '#ffff00' : '#ff0000';
        ctx.fillRect(barX, barY, barWidth * healthPercent, barHeight);
      });

      const bulletColor = window.elementSdk?.config?.bullet_color || defaultConfig.bullet_color;
      ctx.fillStyle = bulletColor;
      bullets.forEach(bullet => {
        ctx.beginPath();
        ctx.arc(bullet.x, bullet.y, bullet.size, 0, Math.PI * 2);
        ctx.fill();
      });

      ctx.fillStyle = '#ffffff';
      ctx.strokeStyle = '#aaaaaa';
      ctx.lineWidth = 1;
      orbs.forEach(orb => {
        ctx.beginPath();
        ctx.arc(orb.x, orb.y, orb.size, 0, Math.PI * 2);
        ctx.fill();
        ctx.stroke();
      });
      
      ctx.fillStyle = '#00ff00';
      ctx.strokeStyle = '#00aa00';
      ctx.lineWidth = 2;
      healthOrbs.forEach(orb => {
        ctx.beginPath();
        ctx.arc(orb.x, orb.y, orb.size, 0, Math.PI * 2);
        ctx.fill();
        ctx.stroke();
      });

      if (gameOver) {
        ctx.fillStyle = 'rgba(0, 0, 0, 0.85)';
        ctx.fillRect(0, 0, canvas.width, canvas.height);
        
        ctx.fillStyle = '#ff4444';
        ctx.font = 'bold 72px Arial';
        ctx.textAlign = 'center';
        ctx.textBaseline = 'middle';
        ctx.shadowColor = 'rgba(0, 0, 0, 0.8)';
        ctx.shadowBlur = 15;
        ctx.fillText('GAME OVER', canvas.width / 2, canvas.height / 2 - 80);
        ctx.shadowBlur = 0;
        
        ctx.fillStyle = '#ffffff';
        ctx.font = '32px Arial';
        ctx.fillText(`ÏÉùÏ°¥ ÏãúÍ∞Ñ: ${finalSurvivalTime}`, canvas.width / 2, canvas.height / 2);
        
        const buttonWidth = 200;
        const buttonHeight = 60;
        const buttonX = canvas.width / 2 - buttonWidth / 2;
        const buttonY = canvas.height / 2 + 60;
        
        ctx.fillStyle = 'rgba(0, 212, 255, 0.8)';
        ctx.strokeStyle = '#00d4ff';
        ctx.lineWidth = 3;
        ctx.fillRect(buttonX, buttonY, buttonWidth, buttonHeight);
        ctx.strokeRect(buttonX, buttonY, buttonWidth, buttonHeight);
        
        ctx.fillStyle = '#ffffff';
        ctx.font = 'bold 24px Arial';
        ctx.fillText('Îã§ÏãúÌïòÍ∏∞', canvas.width / 2, buttonY + buttonHeight / 2);
      }
      else if (showLevelUpChoice) {
        ctx.fillStyle = 'rgba(0, 0, 0, 0.8)';
        ctx.fillRect(0, 0, canvas.width, canvas.height);
        
        ctx.fillStyle = '#FFD700';
        ctx.font = 'bold 48px Arial';
        ctx.textAlign = 'center';
        ctx.textBaseline = 'middle';
        ctx.fillText('Î†àÎ≤® ÏóÖ!', canvas.width / 2, canvas.height / 2 - 150);
        
        ctx.fillStyle = '#ffffff';
        ctx.font = '24px Arial';
        ctx.fillText('ÏóÖÍ∑∏Î†àÏù¥ÎìúÎ•º ÏÑ†ÌÉùÌïòÏÑ∏Ïöî', canvas.width / 2, canvas.height / 2 - 90);
        
        const boxWidth = 200;
        const boxHeight = 120;
        const boxY = canvas.height / 2 - 30;
        const spacing = 20;
        const totalWidth = boxWidth * 3 + spacing * 2;
        const startX = canvas.width / 2 - totalWidth / 2;
        
        for (let i = 0; i < 3; i++) {
          const upgrade = currentUpgradeOptions[i];
          const boxX = startX + i * (boxWidth + spacing);
          
          ctx.fillStyle = upgrade.color;
          ctx.strokeStyle = upgrade.borderColor;
          ctx.lineWidth = 3;
          ctx.fillRect(boxX, boxY, boxWidth, boxHeight);
          ctx.strokeRect(boxX, boxY, boxWidth, boxHeight);
          
          ctx.fillStyle = '#ffffff';
          ctx.font = 'bold 20px Arial';
          ctx.fillText(`${upgrade.name} +${upgrade.value}%`, boxX + boxWidth / 2, boxY + 40);
          ctx.font = '16px Arial';
          ctx.fillText(`(${i + 1}Î≤à ÌÇ§)`, boxX + boxWidth / 2, boxY + 70);
        }
      }
      else if (gamePaused && gameStarted && !showLevelUpChoice) {
        ctx.fillStyle = 'rgba(0, 0, 0, 0.7)';
        ctx.fillRect(0, 0, canvas.width, canvas.height);
        
        const textColor = window.elementSdk?.config?.text_color || defaultConfig.text_color;
        ctx.fillStyle = textColor;
        ctx.font = 'bold 64px Arial';
        ctx.textAlign = 'center';
        ctx.textBaseline = 'middle';
        ctx.shadowColor = 'rgba(0, 0, 0, 0.8)';
        ctx.shadowBlur = 10;
        ctx.fillText('ÏùºÏãú Ï†ïÏßÄ', canvas.width / 2, canvas.height / 2);
        ctx.shadowBlur = 0;
        
        ctx.font = '24px Arial';
        ctx.globalAlpha = 0.8;
        ctx.fillText('Ï†ïÏßÄ Î≤ÑÌäºÏùÑ Îã§Ïãú ÎàåÎü¨ Í≥ÑÏÜçÌïòÏÑ∏Ïöî', canvas.width / 2, canvas.height / 2 + 60);
        ctx.globalAlpha = 1;
      }
    }

    function gameLoop(timestamp) {
      hideUIOnStartScreen();
      
      if (gameStarted && !gamePaused) {
        // Ïã§Ï†ú ÌîåÎ†àÏù¥ ÏãúÍ∞Ñ Í∏∞Ï§ÄÏúºÎ°ú Ï†Å ÏÉùÏÑ±Î•† Í≥ÑÏÇ∞
        const actualPlayTime = Date.now() - gameStartTime - pausedTime;
        const currentPhase = Math.floor(actualPlayTime / 30000);
        const enemiesPerWave = 2 + currentPhase;
        enemySpawnInterval = 2000 / enemiesPerWave;
        
        if (timestamp - lastEnemySpawn > enemySpawnInterval) {
          spawnEnemy();
          lastEnemySpawn = timestamp;
        }

        const currentAutoShootInterval = autoShootInterval * (1 - attackSpeedBonus);
        if (timestamp - lastAutoShoot > currentAutoShootInterval) {
          autoShoot();
          lastAutoShoot = timestamp;
        }

        updatePlayer();
        updateEnemies();
        updateBullets();
        updateOrbs();
        updateSurvivalTime();
      }
      
      draw();

      requestAnimationFrame(gameLoop);
    }

    async function onConfigChange(config) {
      const gameTitle = document.getElementById('gameTitle');
      const playerLabel = document.getElementById('playerLabel');
      const healthLabel = document.getElementById('healthLabel');
      const survivalTime = document.getElementById('survivalTime');
      
      gameTitle.textContent = config.game_title || defaultConfig.game_title;
      playerLabel.textContent = config.player_label || defaultConfig.player_label;
      healthLabel.textContent = config.health_label || defaultConfig.health_label;
      
      const textColor = config.text_color || defaultConfig.text_color;
      gameTitle.style.color = textColor;
      playerLabel.style.color = textColor;
      healthLabel.style.color = textColor;
      survivalTime.style.color = textColor;
      document.getElementById('healthValue').style.color = textColor;
      document.getElementById('levelValue').style.color = textColor;
      
      updateSurvivalTime();
      updateLevelDisplay();
    }

    if (window.elementSdk) {
      window.elementSdk.init({
        defaultConfig,
        onConfigChange,
        mapToCapabilities: (config) => ({
          recolorables: [
            {
              get: () => config.background_color || defaultConfig.background_color,
              set: (value) => {
                config.background_color = value;
                window.elementSdk.setConfig({ background_color: value });
              }
            },
            {
              get: () => config.player_color || defaultConfig.player_color,
              set: (value) => {
                config.player_color = value;
                window.elementSdk.setConfig({ player_color: value });
              }
            },
            {
              get: () => config.enemy_color || defaultConfig.enemy_color,
              set: (value) => {
                config.enemy_color = value;
                window.elementSdk.setConfig({ enemy_color: value });
              }
            },
            {
              get: () => config.bullet_color || defaultConfig.bullet_color,
              set: (value) => {
                config.bullet_color = value;
                window.elementSdk.setConfig({ bullet_color: value });
              }
            },
            {
              get: () => config.text_color || defaultConfig.text_color,
              set: (value) => {
                config.text_color = value;
                window.elementSdk.setConfig({ text_color: value });
              }
            }
          ],
          borderables: [],
          fontEditable: undefined,
          fontSizeable: undefined
        }),
        mapToEditPanelValues: (config) => new Map([
          ["game_title", config.game_title || defaultConfig.game_title],
          ["player_label", config.player_label || defaultConfig.player_label],
          ["health_label", config.health_label || defaultConfig.health_label],
          ["survival_label", config.survival_label || defaultConfig.survival_label]
        ])
      });
    }

    requestAnimationFrame(gameLoop);
  </script>
 <script>(function(){function c(){var b=a.contentDocument||a.contentWindow.document;if(b){var d=b.createElement('script');d.innerHTML="window.__CF$cv$params={r:'9ba7d078a74f3085',t:'MTc2NzgzNDYxOC4wMDAwMDA='};var a=document.createElement('script');a.nonce='';a.src='/cdn-cgi/challenge-platform/scripts/jsd/main.js';document.getElementsByTagName('head')[0].appendChild(a);";b.getElementsByTagName('head')[0].appendChild(d)}}if(document.body){var a=document.createElement('iframe');a.height=1;a.width=1;a.style.position='absolute';a.style.top=0;a.style.left=0;a.style.border='none';a.style.visibility='hidden';document.body.appendChild(a);if('loading'!==document.readyState)c();else if(window.addEventListener)document.addEventListener('DOMContentLoaded',c);else{var e=document.onreadystatechange||function(){};document.onreadystatechange=function(b){e(b);'loading'!==document.readyState&&(document.onreadystatechange=e,c())}}}})();</script></body>
</html>
